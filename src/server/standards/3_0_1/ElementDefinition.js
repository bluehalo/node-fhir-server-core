const Element = require('./Element');
const UnsignedIntScalar = require('./scalars/UnsignedInt.scalar');
const UriScalar = require('./scalars/Uri.scalar');
const Base64BinaryScalar = require('./scalars/Base64Binary.scalar');
const CodeScalar = require('./scalars/Code.scalar');
const DateScalar = require('./scalars/Date.scalar');
const DateTimeScalar = require('./scalars/DateTime.scalar');
const IdScalar = require('./scalars/Id.scalar');
const InstantScalar = require('./scalars/Instant.scalar');
const OidScalar = require('./scalars/Oid.scalar');
const PositiveIntScalar = require('./scalars/PositiveInt.scalar');
const TimeScalar = require('./scalars/Time.scalar');

class ElementDefinition extends Element {
	constructor(opt) {
		super(opt);
		this.__resourceType = 'ElementDefinition';
		Object.assign(this, opt);
	}

	// This is a ElementDefinition resource
	static get __resourceType() {
		return 'ElementDefinition';
	}

	// The path identifies the element and is expressed as a \'.\'-separated list of ancestor elements, beginning with the name of the resource or extension.
	get path() {
		return this.__path;
	}

	set path(new_value) {
		this.__path = new_value;
	}

	// Codes that define how this element is represented in instances, when the deviation varies from the normal case.
	get representation() {
		return this.__representation;
	}

	set representation(new_value) {
		this.__representation = Array.isArray(new_value) ? new_value : [new_value];
	}

	// The name of this element definition slice, when slicing is working. The name must be a token with no dots or spaces. This is a unique name referring to a specific set of constraints applied to this element, used to provide a name to different slices of the same element.
	get sliceName() {
		return this.__sliceName;
	}

	set sliceName(new_value) {
		this.__sliceName = new_value;
	}

	// A single preferred label which is the text to display beside the element indicating its meaning or to use to prompt for the element in a user display or form.
	get label() {
		return this.__label;
	}

	set label(new_value) {
		this.__label = new_value;
	}

	// A code that has the same meaning as the element in a particular terminology.
	get code() {
		return this.__code;
	}

	set code(new_value) {
		const Coding = require('./Coding');
		this.__code = Array.isArray(new_value) ? new_value.map(val => new Coding(val)) : [new Coding(new_value)];
	}

	// Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
	get slicing() {
		return this.__slicing;
	}

	set slicing(new_value) {
		const ElementDefinitionSlicing = require('./ElementDefinitionSlicing');
		this.__slicing = new ElementDefinitionSlicing(new_value);
	}

	// A concise description of what this element means (e.g. for use in autogenerated summaries).
	get short() {
		return this.__short;
	}

	set short(new_value) {
		this.__short = new_value;
	}

	// Provides a complete explanation of the meaning of the data element for human readability.  For the case of elements derived from existing elements (e.g. constraints), the definition SHALL be consistent with the base definition, but convey the meaning of the element in the particular context of use of the resource.
	get definition() {
		return this.__definition;
	}

	set definition(new_value) {
		this.__definition = new_value;
	}

	// Explanatory notes and implementation guidance about the data element, including notes about how to use the data properly, exceptions to proper use, etc.
	get comment() {
		return this.__comment;
	}

	set comment(new_value) {
		this.__comment = new_value;
	}

	// This element is for traceability of why the element was created and why the constraints exist as they do. This may be used to point to source materials or specifications that drove the structure of this element.
	get requirements() {
		return this.__requirements;
	}

	set requirements(new_value) {
		this.__requirements = new_value;
	}

	// Identifies additional names by which this element might also be known.
	get alias() {
		return this.__alias;
	}

	set alias(new_value) {
		this.__alias = Array.isArray(new_value) ? new_value : [new_value];
	}

	// The minimum number of times this element SHALL appear in the instance.
	get min() {
		return this.__min;
	}

	set min(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UnsignedIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field min`);
		}
		this.__min = new_value;
	}

	// The maximum number of times this element is permitted to appear in the instance.
	get max() {
		return this.__max;
	}

	set max(new_value) {
		this.__max = new_value;
	}

	// Information about the base definition of the element, provided to make it unnecessary for tools to trace the deviation of the element through the derived and related profiles. This information is provided when the element definition is not the original definition of an element - i.g. either in a constraint on another type, or for elements from a super type in a snap shot.
	get base() {
		return this.__base;
	}

	set base(new_value) {
		const ElementDefinitionBase = require('./ElementDefinitionBase');
		this.__base = new ElementDefinitionBase(new_value);
	}

	// Identifies the identity of an element defined elsewhere in the profile whose content rules should be applied to the current element.
	get contentReference() {
		return this.__contentReference;
	}

	set contentReference(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UriScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field contentReference`);
		}
		this.__contentReference = new_value;
	}

	// The data type or resource that the value of this element is permitted to be.
	get type() {
		return this.__type;
	}

	set type(new_value) {
		const ElementDefinitionType = require('./ElementDefinitionType');
		this.__type = Array.isArray(new_value)
			? new_value.map(val => new ElementDefinitionType(val))
			: [new ElementDefinitionType(new_value)];
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueBase64Binary() {
		return this.__defaultValueBase64Binary;
	}

	set defaultValueBase64Binary(new_value) {
		// Throw if new value does not match the pattern
		let pattern = Base64BinaryScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueBase64Binary`);
		}
		this.__defaultValueBase64Binary = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueBoolean() {
		return this.__defaultValueBoolean;
	}

	set defaultValueBoolean(new_value) {
		this.__defaultValueBoolean = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueCode() {
		return this.__defaultValueCode;
	}

	set defaultValueCode(new_value) {
		// Throw if new value does not match the pattern
		let pattern = CodeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueCode`);
		}
		this.__defaultValueCode = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueDate() {
		return this.__defaultValueDate;
	}

	set defaultValueDate(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueDate`);
		}
		this.__defaultValueDate = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueDateTime() {
		return this.__defaultValueDateTime;
	}

	set defaultValueDateTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateTimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueDateTime`);
		}
		this.__defaultValueDateTime = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueDecimal() {
		return this.__defaultValueDecimal;
	}

	set defaultValueDecimal(new_value) {
		this.__defaultValueDecimal = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueId() {
		return this.__defaultValueId;
	}

	set defaultValueId(new_value) {
		// Throw if new value does not match the pattern
		let pattern = IdScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueId`);
		}
		this.__defaultValueId = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueInstant() {
		return this.__defaultValueInstant;
	}

	set defaultValueInstant(new_value) {
		// Throw if new value does not match the pattern
		let pattern = InstantScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueInstant`);
		}
		this.__defaultValueInstant = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueInteger() {
		return this.__defaultValueInteger;
	}

	set defaultValueInteger(new_value) {
		this.__defaultValueInteger = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueMarkdown() {
		return this.__defaultValueMarkdown;
	}

	set defaultValueMarkdown(new_value) {
		this.__defaultValueMarkdown = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueOid() {
		return this.__defaultValueOid;
	}

	set defaultValueOid(new_value) {
		// Throw if new value does not match the pattern
		let pattern = OidScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueOid`);
		}
		this.__defaultValueOid = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValuePositiveInt() {
		return this.__defaultValuePositiveInt;
	}

	set defaultValuePositiveInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = PositiveIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValuePositiveInt`);
		}
		this.__defaultValuePositiveInt = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueString() {
		return this.__defaultValueString;
	}

	set defaultValueString(new_value) {
		this.__defaultValueString = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueTime() {
		return this.__defaultValueTime;
	}

	set defaultValueTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = TimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueTime`);
		}
		this.__defaultValueTime = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueUnsignedInt() {
		return this.__defaultValueUnsignedInt;
	}

	set defaultValueUnsignedInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UnsignedIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueUnsignedInt`);
		}
		this.__defaultValueUnsignedInt = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueUri() {
		return this.__defaultValueUri;
	}

	set defaultValueUri(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UriScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field defaultValueUri`);
		}
		this.__defaultValueUri = new_value;
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueAddress() {
		return this.__defaultValueAddress;
	}

	set defaultValueAddress(new_value) {
		const Address = require('./Address');
		this.__defaultValueAddress = new Address(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueAge() {
		return this.__defaultValueAge;
	}

	set defaultValueAge(new_value) {
		const Age = require('./Age');
		this.__defaultValueAge = new Age(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueAnnotation() {
		return this.__defaultValueAnnotation;
	}

	set defaultValueAnnotation(new_value) {
		const Annotation = require('./Annotation');
		this.__defaultValueAnnotation = new Annotation(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueAttachment() {
		return this.__defaultValueAttachment;
	}

	set defaultValueAttachment(new_value) {
		const Attachment = require('./Attachment');
		this.__defaultValueAttachment = new Attachment(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueCodeableConcept() {
		return this.__defaultValueCodeableConcept;
	}

	set defaultValueCodeableConcept(new_value) {
		const CodeableConcept = require('./CodeableConcept');
		this.__defaultValueCodeableConcept = new CodeableConcept(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueCoding() {
		return this.__defaultValueCoding;
	}

	set defaultValueCoding(new_value) {
		const Coding = require('./Coding');
		this.__defaultValueCoding = new Coding(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueContactPoint() {
		return this.__defaultValueContactPoint;
	}

	set defaultValueContactPoint(new_value) {
		const ContactPoint = require('./ContactPoint');
		this.__defaultValueContactPoint = new ContactPoint(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueCount() {
		return this.__defaultValueCount;
	}

	set defaultValueCount(new_value) {
		const Count = require('./Count');
		this.__defaultValueCount = new Count(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueDistance() {
		return this.__defaultValueDistance;
	}

	set defaultValueDistance(new_value) {
		const Distance = require('./Distance');
		this.__defaultValueDistance = new Distance(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueDuration() {
		return this.__defaultValueDuration;
	}

	set defaultValueDuration(new_value) {
		const Duration = require('./Duration');
		this.__defaultValueDuration = new Duration(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueHumanName() {
		return this.__defaultValueHumanName;
	}

	set defaultValueHumanName(new_value) {
		const HumanName = require('./HumanName');
		this.__defaultValueHumanName = new HumanName(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueIdentifier() {
		return this.__defaultValueIdentifier;
	}

	set defaultValueIdentifier(new_value) {
		const Identifier = require('./Identifier');
		this.__defaultValueIdentifier = new Identifier(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueMoney() {
		return this.__defaultValueMoney;
	}

	set defaultValueMoney(new_value) {
		const Money = require('./Money');
		this.__defaultValueMoney = new Money(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValuePeriod() {
		return this.__defaultValuePeriod;
	}

	set defaultValuePeriod(new_value) {
		const Period = require('./Period');
		this.__defaultValuePeriod = new Period(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueQuantity() {
		return this.__defaultValueQuantity;
	}

	set defaultValueQuantity(new_value) {
		const Quantity = require('./Quantity');
		this.__defaultValueQuantity = new Quantity(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueRange() {
		return this.__defaultValueRange;
	}

	set defaultValueRange(new_value) {
		const Range = require('./Range');
		this.__defaultValueRange = new Range(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueRatio() {
		return this.__defaultValueRatio;
	}

	set defaultValueRatio(new_value) {
		const Ratio = require('./Ratio');
		this.__defaultValueRatio = new Ratio(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueReference() {
		return this.__defaultValueReference;
	}

	set defaultValueReference(new_value) {
		const Reference = require('./Reference');
		this.__defaultValueReference = new Reference(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueSampledData() {
		return this.__defaultValueSampledData;
	}

	set defaultValueSampledData(new_value) {
		const SampledData = require('./SampledData');
		this.__defaultValueSampledData = new SampledData(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueSignature() {
		return this.__defaultValueSignature;
	}

	set defaultValueSignature(new_value) {
		const Signature = require('./Signature');
		this.__defaultValueSignature = new Signature(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueTiming() {
		return this.__defaultValueTiming;
	}

	set defaultValueTiming(new_value) {
		const Timing = require('./Timing');
		this.__defaultValueTiming = new Timing(new_value);
	}

	// The value that should be used if there is no value stated in the instance (e.g. \'if not otherwise specified, the abstract is false\').
	get defaultValueMeta() {
		return this.__defaultValueMeta;
	}

	set defaultValueMeta(new_value) {
		const Meta = require('./Meta');
		this.__defaultValueMeta = new Meta(new_value);
	}

	// The Implicit meaning that is to be understood when this element is missing (e.g. \'when this element is missing, the period is ongoing\'.
	get meaningWhenMissing() {
		return this.__meaningWhenMissing;
	}

	set meaningWhenMissing(new_value) {
		this.__meaningWhenMissing = new_value;
	}

	// If present, indicates that the order of the repeating element has meaning and describes what that meaning is.  If absent, it means that the order of the element has no meaning.
	get orderMeaning() {
		return this.__orderMeaning;
	}

	set orderMeaning(new_value) {
		this.__orderMeaning = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedBase64Binary() {
		return this.__fixedBase64Binary;
	}

	set fixedBase64Binary(new_value) {
		// Throw if new value does not match the pattern
		let pattern = Base64BinaryScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedBase64Binary`);
		}
		this.__fixedBase64Binary = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedBoolean() {
		return this.__fixedBoolean;
	}

	set fixedBoolean(new_value) {
		this.__fixedBoolean = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedCode() {
		return this.__fixedCode;
	}

	set fixedCode(new_value) {
		// Throw if new value does not match the pattern
		let pattern = CodeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedCode`);
		}
		this.__fixedCode = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedDate() {
		return this.__fixedDate;
	}

	set fixedDate(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedDate`);
		}
		this.__fixedDate = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedDateTime() {
		return this.__fixedDateTime;
	}

	set fixedDateTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateTimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedDateTime`);
		}
		this.__fixedDateTime = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedDecimal() {
		return this.__fixedDecimal;
	}

	set fixedDecimal(new_value) {
		this.__fixedDecimal = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedId() {
		return this.__fixedId;
	}

	set fixedId(new_value) {
		// Throw if new value does not match the pattern
		let pattern = IdScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedId`);
		}
		this.__fixedId = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedInstant() {
		return this.__fixedInstant;
	}

	set fixedInstant(new_value) {
		// Throw if new value does not match the pattern
		let pattern = InstantScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedInstant`);
		}
		this.__fixedInstant = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedInteger() {
		return this.__fixedInteger;
	}

	set fixedInteger(new_value) {
		this.__fixedInteger = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedMarkdown() {
		return this.__fixedMarkdown;
	}

	set fixedMarkdown(new_value) {
		this.__fixedMarkdown = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedOid() {
		return this.__fixedOid;
	}

	set fixedOid(new_value) {
		// Throw if new value does not match the pattern
		let pattern = OidScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedOid`);
		}
		this.__fixedOid = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedPositiveInt() {
		return this.__fixedPositiveInt;
	}

	set fixedPositiveInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = PositiveIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedPositiveInt`);
		}
		this.__fixedPositiveInt = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedString() {
		return this.__fixedString;
	}

	set fixedString(new_value) {
		this.__fixedString = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedTime() {
		return this.__fixedTime;
	}

	set fixedTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = TimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedTime`);
		}
		this.__fixedTime = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedUnsignedInt() {
		return this.__fixedUnsignedInt;
	}

	set fixedUnsignedInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UnsignedIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedUnsignedInt`);
		}
		this.__fixedUnsignedInt = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedUri() {
		return this.__fixedUri;
	}

	set fixedUri(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UriScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field fixedUri`);
		}
		this.__fixedUri = new_value;
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedAddress() {
		return this.__fixedAddress;
	}

	set fixedAddress(new_value) {
		const Address = require('./Address');
		this.__fixedAddress = new Address(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedAge() {
		return this.__fixedAge;
	}

	set fixedAge(new_value) {
		const Age = require('./Age');
		this.__fixedAge = new Age(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedAnnotation() {
		return this.__fixedAnnotation;
	}

	set fixedAnnotation(new_value) {
		const Annotation = require('./Annotation');
		this.__fixedAnnotation = new Annotation(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedAttachment() {
		return this.__fixedAttachment;
	}

	set fixedAttachment(new_value) {
		const Attachment = require('./Attachment');
		this.__fixedAttachment = new Attachment(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedCodeableConcept() {
		return this.__fixedCodeableConcept;
	}

	set fixedCodeableConcept(new_value) {
		const CodeableConcept = require('./CodeableConcept');
		this.__fixedCodeableConcept = new CodeableConcept(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedCoding() {
		return this.__fixedCoding;
	}

	set fixedCoding(new_value) {
		const Coding = require('./Coding');
		this.__fixedCoding = new Coding(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedContactPoint() {
		return this.__fixedContactPoint;
	}

	set fixedContactPoint(new_value) {
		const ContactPoint = require('./ContactPoint');
		this.__fixedContactPoint = new ContactPoint(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedCount() {
		return this.__fixedCount;
	}

	set fixedCount(new_value) {
		const Count = require('./Count');
		this.__fixedCount = new Count(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedDistance() {
		return this.__fixedDistance;
	}

	set fixedDistance(new_value) {
		const Distance = require('./Distance');
		this.__fixedDistance = new Distance(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedDuration() {
		return this.__fixedDuration;
	}

	set fixedDuration(new_value) {
		const Duration = require('./Duration');
		this.__fixedDuration = new Duration(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedHumanName() {
		return this.__fixedHumanName;
	}

	set fixedHumanName(new_value) {
		const HumanName = require('./HumanName');
		this.__fixedHumanName = new HumanName(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedIdentifier() {
		return this.__fixedIdentifier;
	}

	set fixedIdentifier(new_value) {
		const Identifier = require('./Identifier');
		this.__fixedIdentifier = new Identifier(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedMoney() {
		return this.__fixedMoney;
	}

	set fixedMoney(new_value) {
		const Money = require('./Money');
		this.__fixedMoney = new Money(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedPeriod() {
		return this.__fixedPeriod;
	}

	set fixedPeriod(new_value) {
		const Period = require('./Period');
		this.__fixedPeriod = new Period(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedQuantity() {
		return this.__fixedQuantity;
	}

	set fixedQuantity(new_value) {
		const Quantity = require('./Quantity');
		this.__fixedQuantity = new Quantity(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedRange() {
		return this.__fixedRange;
	}

	set fixedRange(new_value) {
		const Range = require('./Range');
		this.__fixedRange = new Range(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedRatio() {
		return this.__fixedRatio;
	}

	set fixedRatio(new_value) {
		const Ratio = require('./Ratio');
		this.__fixedRatio = new Ratio(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedReference() {
		return this.__fixedReference;
	}

	set fixedReference(new_value) {
		const Reference = require('./Reference');
		this.__fixedReference = new Reference(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedSampledData() {
		return this.__fixedSampledData;
	}

	set fixedSampledData(new_value) {
		const SampledData = require('./SampledData');
		this.__fixedSampledData = new SampledData(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedSignature() {
		return this.__fixedSignature;
	}

	set fixedSignature(new_value) {
		const Signature = require('./Signature');
		this.__fixedSignature = new Signature(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedTiming() {
		return this.__fixedTiming;
	}

	set fixedTiming(new_value) {
		const Timing = require('./Timing');
		this.__fixedTiming = new Timing(new_value);
	}

	// Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
	get fixedMeta() {
		return this.__fixedMeta;
	}

	set fixedMeta(new_value) {
		const Meta = require('./Meta');
		this.__fixedMeta = new Meta(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternBase64Binary() {
		return this.__patternBase64Binary;
	}

	set patternBase64Binary(new_value) {
		// Throw if new value does not match the pattern
		let pattern = Base64BinaryScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternBase64Binary`);
		}
		this.__patternBase64Binary = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternBoolean() {
		return this.__patternBoolean;
	}

	set patternBoolean(new_value) {
		this.__patternBoolean = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternCode() {
		return this.__patternCode;
	}

	set patternCode(new_value) {
		// Throw if new value does not match the pattern
		let pattern = CodeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternCode`);
		}
		this.__patternCode = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternDate() {
		return this.__patternDate;
	}

	set patternDate(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternDate`);
		}
		this.__patternDate = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternDateTime() {
		return this.__patternDateTime;
	}

	set patternDateTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateTimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternDateTime`);
		}
		this.__patternDateTime = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternDecimal() {
		return this.__patternDecimal;
	}

	set patternDecimal(new_value) {
		this.__patternDecimal = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternId() {
		return this.__patternId;
	}

	set patternId(new_value) {
		// Throw if new value does not match the pattern
		let pattern = IdScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternId`);
		}
		this.__patternId = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternInstant() {
		return this.__patternInstant;
	}

	set patternInstant(new_value) {
		// Throw if new value does not match the pattern
		let pattern = InstantScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternInstant`);
		}
		this.__patternInstant = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternInteger() {
		return this.__patternInteger;
	}

	set patternInteger(new_value) {
		this.__patternInteger = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternMarkdown() {
		return this.__patternMarkdown;
	}

	set patternMarkdown(new_value) {
		this.__patternMarkdown = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternOid() {
		return this.__patternOid;
	}

	set patternOid(new_value) {
		// Throw if new value does not match the pattern
		let pattern = OidScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternOid`);
		}
		this.__patternOid = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternPositiveInt() {
		return this.__patternPositiveInt;
	}

	set patternPositiveInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = PositiveIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternPositiveInt`);
		}
		this.__patternPositiveInt = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternString() {
		return this.__patternString;
	}

	set patternString(new_value) {
		this.__patternString = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternTime() {
		return this.__patternTime;
	}

	set patternTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = TimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternTime`);
		}
		this.__patternTime = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternUnsignedInt() {
		return this.__patternUnsignedInt;
	}

	set patternUnsignedInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UnsignedIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternUnsignedInt`);
		}
		this.__patternUnsignedInt = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternUri() {
		return this.__patternUri;
	}

	set patternUri(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UriScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field patternUri`);
		}
		this.__patternUri = new_value;
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternAddress() {
		return this.__patternAddress;
	}

	set patternAddress(new_value) {
		const Address = require('./Address');
		this.__patternAddress = new Address(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternAge() {
		return this.__patternAge;
	}

	set patternAge(new_value) {
		const Age = require('./Age');
		this.__patternAge = new Age(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternAnnotation() {
		return this.__patternAnnotation;
	}

	set patternAnnotation(new_value) {
		const Annotation = require('./Annotation');
		this.__patternAnnotation = new Annotation(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternAttachment() {
		return this.__patternAttachment;
	}

	set patternAttachment(new_value) {
		const Attachment = require('./Attachment');
		this.__patternAttachment = new Attachment(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternCodeableConcept() {
		return this.__patternCodeableConcept;
	}

	set patternCodeableConcept(new_value) {
		const CodeableConcept = require('./CodeableConcept');
		this.__patternCodeableConcept = new CodeableConcept(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternCoding() {
		return this.__patternCoding;
	}

	set patternCoding(new_value) {
		const Coding = require('./Coding');
		this.__patternCoding = new Coding(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternContactPoint() {
		return this.__patternContactPoint;
	}

	set patternContactPoint(new_value) {
		const ContactPoint = require('./ContactPoint');
		this.__patternContactPoint = new ContactPoint(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternCount() {
		return this.__patternCount;
	}

	set patternCount(new_value) {
		const Count = require('./Count');
		this.__patternCount = new Count(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternDistance() {
		return this.__patternDistance;
	}

	set patternDistance(new_value) {
		const Distance = require('./Distance');
		this.__patternDistance = new Distance(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternDuration() {
		return this.__patternDuration;
	}

	set patternDuration(new_value) {
		const Duration = require('./Duration');
		this.__patternDuration = new Duration(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternHumanName() {
		return this.__patternHumanName;
	}

	set patternHumanName(new_value) {
		const HumanName = require('./HumanName');
		this.__patternHumanName = new HumanName(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternIdentifier() {
		return this.__patternIdentifier;
	}

	set patternIdentifier(new_value) {
		const Identifier = require('./Identifier');
		this.__patternIdentifier = new Identifier(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternMoney() {
		return this.__patternMoney;
	}

	set patternMoney(new_value) {
		const Money = require('./Money');
		this.__patternMoney = new Money(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternPeriod() {
		return this.__patternPeriod;
	}

	set patternPeriod(new_value) {
		const Period = require('./Period');
		this.__patternPeriod = new Period(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternQuantity() {
		return this.__patternQuantity;
	}

	set patternQuantity(new_value) {
		const Quantity = require('./Quantity');
		this.__patternQuantity = new Quantity(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternRange() {
		return this.__patternRange;
	}

	set patternRange(new_value) {
		const Range = require('./Range');
		this.__patternRange = new Range(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternRatio() {
		return this.__patternRatio;
	}

	set patternRatio(new_value) {
		const Ratio = require('./Ratio');
		this.__patternRatio = new Ratio(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternReference() {
		return this.__patternReference;
	}

	set patternReference(new_value) {
		const Reference = require('./Reference');
		this.__patternReference = new Reference(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternSampledData() {
		return this.__patternSampledData;
	}

	set patternSampledData(new_value) {
		const SampledData = require('./SampledData');
		this.__patternSampledData = new SampledData(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternSignature() {
		return this.__patternSignature;
	}

	set patternSignature(new_value) {
		const Signature = require('./Signature');
		this.__patternSignature = new Signature(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternTiming() {
		return this.__patternTiming;
	}

	set patternTiming(new_value) {
		const Timing = require('./Timing');
		this.__patternTiming = new Timing(new_value);
	}

	// Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.  The values of elements present in the pattern must match exactly (case-sensitive, accent-sensitive, etc.).
	get patternMeta() {
		return this.__patternMeta;
	}

	set patternMeta(new_value) {
		const Meta = require('./Meta');
		this.__patternMeta = new Meta(new_value);
	}

	// A sample value for this element demonstrating the type of information that would typically be found in the element.
	get example() {
		return this.__example;
	}

	set example(new_value) {
		const ElementDefinitionExample = require('./ElementDefinitionExample');
		this.__example = Array.isArray(new_value)
			? new_value.map(val => new ElementDefinitionExample(val))
			: [new ElementDefinitionExample(new_value)];
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueDate() {
		return this.__minValueDate;
	}

	set minValueDate(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValueDate`);
		}
		this.__minValueDate = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueDateTime() {
		return this.__minValueDateTime;
	}

	set minValueDateTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateTimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValueDateTime`);
		}
		this.__minValueDateTime = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueInstant() {
		return this.__minValueInstant;
	}

	set minValueInstant(new_value) {
		// Throw if new value does not match the pattern
		let pattern = InstantScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValueInstant`);
		}
		this.__minValueInstant = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueTime() {
		return this.__minValueTime;
	}

	set minValueTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = TimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValueTime`);
		}
		this.__minValueTime = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueDecimal() {
		return this.__minValueDecimal;
	}

	set minValueDecimal(new_value) {
		this.__minValueDecimal = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueInteger() {
		return this.__minValueInteger;
	}

	set minValueInteger(new_value) {
		this.__minValueInteger = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValuePositiveInt() {
		return this.__minValuePositiveInt;
	}

	set minValuePositiveInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = PositiveIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValuePositiveInt`);
		}
		this.__minValuePositiveInt = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueUnsignedInt() {
		return this.__minValueUnsignedInt;
	}

	set minValueUnsignedInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UnsignedIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field minValueUnsignedInt`);
		}
		this.__minValueUnsignedInt = new_value;
	}

	// The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get minValueQuantity() {
		return this.__minValueQuantity;
	}

	set minValueQuantity(new_value) {
		const Quantity = require('./Quantity');
		this.__minValueQuantity = new Quantity(new_value);
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueDate() {
		return this.__maxValueDate;
	}

	set maxValueDate(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValueDate`);
		}
		this.__maxValueDate = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueDateTime() {
		return this.__maxValueDateTime;
	}

	set maxValueDateTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = DateTimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValueDateTime`);
		}
		this.__maxValueDateTime = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueInstant() {
		return this.__maxValueInstant;
	}

	set maxValueInstant(new_value) {
		// Throw if new value does not match the pattern
		let pattern = InstantScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValueInstant`);
		}
		this.__maxValueInstant = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueTime() {
		return this.__maxValueTime;
	}

	set maxValueTime(new_value) {
		// Throw if new value does not match the pattern
		let pattern = TimeScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValueTime`);
		}
		this.__maxValueTime = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueDecimal() {
		return this.__maxValueDecimal;
	}

	set maxValueDecimal(new_value) {
		this.__maxValueDecimal = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueInteger() {
		return this.__maxValueInteger;
	}

	set maxValueInteger(new_value) {
		this.__maxValueInteger = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValuePositiveInt() {
		return this.__maxValuePositiveInt;
	}

	set maxValuePositiveInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = PositiveIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValuePositiveInt`);
		}
		this.__maxValuePositiveInt = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueUnsignedInt() {
		return this.__maxValueUnsignedInt;
	}

	set maxValueUnsignedInt(new_value) {
		// Throw if new value does not match the pattern
		let pattern = UnsignedIntScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field maxValueUnsignedInt`);
		}
		this.__maxValueUnsignedInt = new_value;
	}

	// The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
	get maxValueQuantity() {
		return this.__maxValueQuantity;
	}

	set maxValueQuantity(new_value) {
		const Quantity = require('./Quantity');
		this.__maxValueQuantity = new Quantity(new_value);
	}

	// Indicates the maximum length in characters that is permitted to be present in conformant instances and which is expected to be supported by conformant consumers that support the element.
	get maxLength() {
		return this.__maxLength;
	}

	set maxLength(new_value) {
		this.__maxLength = new_value;
	}

	// A reference to an invariant that may make additional statements about the cardinality or value in the instance.
	get condition() {
		return this.__condition;
	}

	set condition(new_value) {
		// Throw if new value does not match the pattern
		let pattern = IdScalar.regex();
		if (new_value && !pattern.test(new_value)) {
			throw new Error(`Invalid format for ${new_value} on field condition`);
		}
		this.__condition = Array.isArray(new_value) ? new_value : [new_value];
	}

	// Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
	get constraint() {
		return this.__constraint;
	}

	set constraint(new_value) {
		const ElementDefinitionConstraint = require('./ElementDefinitionConstraint');
		this.__constraint = Array.isArray(new_value)
			? new_value.map(val => new ElementDefinitionConstraint(val))
			: [new ElementDefinitionConstraint(new_value)];
	}

	// If true, implementations that produce or consume resources SHALL provide \'support\' for the element in some meaningful way.  If false, the element may be ignored and not supported.
	get mustSupport() {
		return this.__mustSupport;
	}

	set mustSupport(new_value) {
		this.__mustSupport = new_value;
	}

	// If true, the value of this element affects the interpretation of the element or resource that contains it, and the value of the element cannot be ignored. Typically, this is used for status, negation and qualification codes. The effect of this is that the element cannot be ignored by systems: they SHALL either recognize the element and process it, and/or a pre-determination has been made that it is not relevant to their particular system.
	get isModifier() {
		return this.__isModifier;
	}

	set isModifier(new_value) {
		this.__isModifier = new_value;
	}

	// Whether the element should be included if a client requests a search with the parameter _summary=true.
	get isSummary() {
		return this.__isSummary;
	}

	set isSummary(new_value) {
		this.__isSummary = new_value;
	}

	// Binds to a value set if this element is coded (code, Coding, CodeableConcept, Quantity), or the data types (string, uri).
	get binding() {
		return this.__binding;
	}

	set binding(new_value) {
		const ElementDefinitionBinding = require('./ElementDefinitionBinding');
		this.__binding = new ElementDefinitionBinding(new_value);
	}

	// Identifies a concept from an external specification that roughly corresponds to this element.
	get mapping() {
		return this.__mapping;
	}

	set mapping(new_value) {
		const ElementDefinitionMapping = require('./ElementDefinitionMapping');
		this.__mapping = Array.isArray(new_value)
			? new_value.map(val => new ElementDefinitionMapping(val))
			: [new ElementDefinitionMapping(new_value)];
	}

	toJSON() {
		return Object.assign(super.toJSON(), {
			path: this.__path,
			representation: this.__representation,
			sliceName: this.__sliceName,
			label: this.__label,
			code: this.__code && this.__code.map(v => v.toJSON()),
			slicing: this.__slicing && this.__slicing.toJSON(),
			short: this.__short,
			definition: this.__definition,
			comment: this.__comment,
			requirements: this.__requirements,
			alias: this.__alias,
			min: this.__min,
			max: this.__max,
			base: this.__base && this.__base.toJSON(),
			contentReference: this.__contentReference,
			type: this.__type && this.__type.map(v => v.toJSON()),
			defaultValueBase64Binary: this.__defaultValueBase64Binary,
			defaultValueBoolean: this.__defaultValueBoolean,
			defaultValueCode: this.__defaultValueCode,
			defaultValueDate: this.__defaultValueDate,
			defaultValueDateTime: this.__defaultValueDateTime,
			defaultValueDecimal: this.__defaultValueDecimal,
			defaultValueId: this.__defaultValueId,
			defaultValueInstant: this.__defaultValueInstant,
			defaultValueInteger: this.__defaultValueInteger,
			defaultValueMarkdown: this.__defaultValueMarkdown,
			defaultValueOid: this.__defaultValueOid,
			defaultValuePositiveInt: this.__defaultValuePositiveInt,
			defaultValueString: this.__defaultValueString,
			defaultValueTime: this.__defaultValueTime,
			defaultValueUnsignedInt: this.__defaultValueUnsignedInt,
			defaultValueUri: this.__defaultValueUri,
			defaultValueAddress: this.__defaultValueAddress && this.__defaultValueAddress.toJSON(),
			defaultValueAge: this.__defaultValueAge && this.__defaultValueAge.toJSON(),
			defaultValueAnnotation: this.__defaultValueAnnotation && this.__defaultValueAnnotation.toJSON(),
			defaultValueAttachment: this.__defaultValueAttachment && this.__defaultValueAttachment.toJSON(),
			defaultValueCodeableConcept: this.__defaultValueCodeableConcept && this.__defaultValueCodeableConcept.toJSON(),
			defaultValueCoding: this.__defaultValueCoding && this.__defaultValueCoding.toJSON(),
			defaultValueContactPoint: this.__defaultValueContactPoint && this.__defaultValueContactPoint.toJSON(),
			defaultValueCount: this.__defaultValueCount && this.__defaultValueCount.toJSON(),
			defaultValueDistance: this.__defaultValueDistance && this.__defaultValueDistance.toJSON(),
			defaultValueDuration: this.__defaultValueDuration && this.__defaultValueDuration.toJSON(),
			defaultValueHumanName: this.__defaultValueHumanName && this.__defaultValueHumanName.toJSON(),
			defaultValueIdentifier: this.__defaultValueIdentifier && this.__defaultValueIdentifier.toJSON(),
			defaultValueMoney: this.__defaultValueMoney && this.__defaultValueMoney.toJSON(),
			defaultValuePeriod: this.__defaultValuePeriod && this.__defaultValuePeriod.toJSON(),
			defaultValueQuantity: this.__defaultValueQuantity && this.__defaultValueQuantity.toJSON(),
			defaultValueRange: this.__defaultValueRange && this.__defaultValueRange.toJSON(),
			defaultValueRatio: this.__defaultValueRatio && this.__defaultValueRatio.toJSON(),
			defaultValueReference: this.__defaultValueReference && this.__defaultValueReference.toJSON(),
			defaultValueSampledData: this.__defaultValueSampledData && this.__defaultValueSampledData.toJSON(),
			defaultValueSignature: this.__defaultValueSignature && this.__defaultValueSignature.toJSON(),
			defaultValueTiming: this.__defaultValueTiming && this.__defaultValueTiming.toJSON(),
			defaultValueMeta: this.__defaultValueMeta && this.__defaultValueMeta.toJSON(),
			meaningWhenMissing: this.__meaningWhenMissing,
			orderMeaning: this.__orderMeaning,
			fixedBase64Binary: this.__fixedBase64Binary,
			fixedBoolean: this.__fixedBoolean,
			fixedCode: this.__fixedCode,
			fixedDate: this.__fixedDate,
			fixedDateTime: this.__fixedDateTime,
			fixedDecimal: this.__fixedDecimal,
			fixedId: this.__fixedId,
			fixedInstant: this.__fixedInstant,
			fixedInteger: this.__fixedInteger,
			fixedMarkdown: this.__fixedMarkdown,
			fixedOid: this.__fixedOid,
			fixedPositiveInt: this.__fixedPositiveInt,
			fixedString: this.__fixedString,
			fixedTime: this.__fixedTime,
			fixedUnsignedInt: this.__fixedUnsignedInt,
			fixedUri: this.__fixedUri,
			fixedAddress: this.__fixedAddress && this.__fixedAddress.toJSON(),
			fixedAge: this.__fixedAge && this.__fixedAge.toJSON(),
			fixedAnnotation: this.__fixedAnnotation && this.__fixedAnnotation.toJSON(),
			fixedAttachment: this.__fixedAttachment && this.__fixedAttachment.toJSON(),
			fixedCodeableConcept: this.__fixedCodeableConcept && this.__fixedCodeableConcept.toJSON(),
			fixedCoding: this.__fixedCoding && this.__fixedCoding.toJSON(),
			fixedContactPoint: this.__fixedContactPoint && this.__fixedContactPoint.toJSON(),
			fixedCount: this.__fixedCount && this.__fixedCount.toJSON(),
			fixedDistance: this.__fixedDistance && this.__fixedDistance.toJSON(),
			fixedDuration: this.__fixedDuration && this.__fixedDuration.toJSON(),
			fixedHumanName: this.__fixedHumanName && this.__fixedHumanName.toJSON(),
			fixedIdentifier: this.__fixedIdentifier && this.__fixedIdentifier.toJSON(),
			fixedMoney: this.__fixedMoney && this.__fixedMoney.toJSON(),
			fixedPeriod: this.__fixedPeriod && this.__fixedPeriod.toJSON(),
			fixedQuantity: this.__fixedQuantity && this.__fixedQuantity.toJSON(),
			fixedRange: this.__fixedRange && this.__fixedRange.toJSON(),
			fixedRatio: this.__fixedRatio && this.__fixedRatio.toJSON(),
			fixedReference: this.__fixedReference && this.__fixedReference.toJSON(),
			fixedSampledData: this.__fixedSampledData && this.__fixedSampledData.toJSON(),
			fixedSignature: this.__fixedSignature && this.__fixedSignature.toJSON(),
			fixedTiming: this.__fixedTiming && this.__fixedTiming.toJSON(),
			fixedMeta: this.__fixedMeta && this.__fixedMeta.toJSON(),
			patternBase64Binary: this.__patternBase64Binary,
			patternBoolean: this.__patternBoolean,
			patternCode: this.__patternCode,
			patternDate: this.__patternDate,
			patternDateTime: this.__patternDateTime,
			patternDecimal: this.__patternDecimal,
			patternId: this.__patternId,
			patternInstant: this.__patternInstant,
			patternInteger: this.__patternInteger,
			patternMarkdown: this.__patternMarkdown,
			patternOid: this.__patternOid,
			patternPositiveInt: this.__patternPositiveInt,
			patternString: this.__patternString,
			patternTime: this.__patternTime,
			patternUnsignedInt: this.__patternUnsignedInt,
			patternUri: this.__patternUri,
			patternAddress: this.__patternAddress && this.__patternAddress.toJSON(),
			patternAge: this.__patternAge && this.__patternAge.toJSON(),
			patternAnnotation: this.__patternAnnotation && this.__patternAnnotation.toJSON(),
			patternAttachment: this.__patternAttachment && this.__patternAttachment.toJSON(),
			patternCodeableConcept: this.__patternCodeableConcept && this.__patternCodeableConcept.toJSON(),
			patternCoding: this.__patternCoding && this.__patternCoding.toJSON(),
			patternContactPoint: this.__patternContactPoint && this.__patternContactPoint.toJSON(),
			patternCount: this.__patternCount && this.__patternCount.toJSON(),
			patternDistance: this.__patternDistance && this.__patternDistance.toJSON(),
			patternDuration: this.__patternDuration && this.__patternDuration.toJSON(),
			patternHumanName: this.__patternHumanName && this.__patternHumanName.toJSON(),
			patternIdentifier: this.__patternIdentifier && this.__patternIdentifier.toJSON(),
			patternMoney: this.__patternMoney && this.__patternMoney.toJSON(),
			patternPeriod: this.__patternPeriod && this.__patternPeriod.toJSON(),
			patternQuantity: this.__patternQuantity && this.__patternQuantity.toJSON(),
			patternRange: this.__patternRange && this.__patternRange.toJSON(),
			patternRatio: this.__patternRatio && this.__patternRatio.toJSON(),
			patternReference: this.__patternReference && this.__patternReference.toJSON(),
			patternSampledData: this.__patternSampledData && this.__patternSampledData.toJSON(),
			patternSignature: this.__patternSignature && this.__patternSignature.toJSON(),
			patternTiming: this.__patternTiming && this.__patternTiming.toJSON(),
			patternMeta: this.__patternMeta && this.__patternMeta.toJSON(),
			example: this.__example && this.__example.map(v => v.toJSON()),
			minValueDate: this.__minValueDate,
			minValueDateTime: this.__minValueDateTime,
			minValueInstant: this.__minValueInstant,
			minValueTime: this.__minValueTime,
			minValueDecimal: this.__minValueDecimal,
			minValueInteger: this.__minValueInteger,
			minValuePositiveInt: this.__minValuePositiveInt,
			minValueUnsignedInt: this.__minValueUnsignedInt,
			minValueQuantity: this.__minValueQuantity && this.__minValueQuantity.toJSON(),
			maxValueDate: this.__maxValueDate,
			maxValueDateTime: this.__maxValueDateTime,
			maxValueInstant: this.__maxValueInstant,
			maxValueTime: this.__maxValueTime,
			maxValueDecimal: this.__maxValueDecimal,
			maxValueInteger: this.__maxValueInteger,
			maxValuePositiveInt: this.__maxValuePositiveInt,
			maxValueUnsignedInt: this.__maxValueUnsignedInt,
			maxValueQuantity: this.__maxValueQuantity && this.__maxValueQuantity.toJSON(),
			maxLength: this.__maxLength,
			condition: this.__condition,
			constraint: this.__constraint && this.__constraint.map(v => v.toJSON()),
			mustSupport: this.__mustSupport,
			isModifier: this.__isModifier,
			isSummary: this.__isSummary,
			binding: this.__binding && this.__binding.toJSON(),
			mapping: this.__mapping && this.__mapping.map(v => v.toJSON()),
		});
	}
}

module.exports = ElementDefinition;
